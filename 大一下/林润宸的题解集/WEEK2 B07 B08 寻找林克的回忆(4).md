# **<span id="section2B07"></span>WEEK2 B07 B08 寻找林克的回忆(4)（这算两道题解吧）**

## 题目分析

**A~P的16*16填数独，绝对是目前学过最难的题目**

1.   每行必须包含所有 16 个字母（不重复）。

2.   每列必须包含所有 16 个字母（不重复）。

3.  每个 4×4 的宫格必须包含所有 16 个字母（不重复）。
    题目保证有唯一解，输出填充完成的数独网格。

## 解题思路

#### ~~抄上一题代码~~，发现完全过不了。怎么办呢

### 那就剪枝剪到死！

## 算法

### 1. **与（2）相同的基础上**

### **2. \* 疯狂地剪枝** 

1. **唯一数字填充：** 若某空格只有 1 个可选数字，直接填充。

2. **行/列/宫格的唯一性剪枝：**

    - 对每一行，若某字母只能填在一个位置，则直接填入。

    - 对每一列和宫格进行同样操作。

3. **最少选择分支：** 选择可选数字个数最少的空格进行递归尝试，减少分支数。

4. **DFS 回溯：**

    - 保存当前状态以便回溯恢复。

    - 递归尝试可选数字，成功则返回，失败则回溯。

## 或者说我们可以尝试另一种变态的算法： （~~跳舞的林克们~~） 舞蹈链

###### 声明：本人研究了一整个晚上只能勉强看懂舞蹈链的内容，所以觉得不配讲太多。

### 前置知识：https://oi-wiki.org/search/dlx/



### 各个模板

```cpp
// 最大节点数MS
// 矩阵行数(n)和列数(m),// 动态节点计数器(idx)
// 每行第一个节点的索引first, 每列的元素个数siz（用于启发式搜索）
constexpr int MS = 1e5 + 5;         
int n, m, idx, first[MS], siz[MS];  
// 节点的左右上下指针
int L[MS], R[MS], U[MS], D[MS];
//节点所属列索引col,节点所属行索引
int col[MS], row[MS];


//remove(c) 表示在 Dancing Links 中删除第 [c] 列以及与其相关的行和列。
void remove(const int& c) {
    L[R[c]] = L[c];  // 从行链表移除c列
    R[L[c]] = R[c];
    
    // 遍历列c的所有行（从D[c]开始，直到回到c）
    for (int i = D[c]; i != c; i = D[i]) {
        // 遍历当前行的所有节点（从R[i]开始，直到回到i）
        for (int j = R[i]; j != i; j = R[j]) {
            // 将节点j从列链表中移除
            // ！！！注意：移除并不是彻底删除，节点只是脱离了链表，我们还是能找到节点并且装回来
            U[D[j]] = U[j];
            D[U[j]] = D[j];
            siz[col[j]]--;  // 更新所在列的节点计数
        }
    }
}

// 恢复列c及其关联行（remove的逆操作）
void recover(const int& c) {
// 逆序遍历列c的所有行（从U[c]开始向上）
    for (int i = U[c]; i != c; i = U[i]) {
        // 逆序遍历当前行的所有节点（从L[i]开始向左）
        for (int j = L[i]; j != i; j = L[j]) {
            U[D[j]] = j;    // 恢复节点在列链表的位置
            D[U[j]] = j;
            siz[col[j]]++;  // 恢复列计数
        }
    }
    // 将列c重新插入行链表
    L[R[c]] = c;
    R[L[c]] = c;
}

// 初始化舞蹈链（r行c列）
void build(const int& r, const int& c) {
    // 初始化列头节点（0~c）
    n = r, m = c;
    for (int i = 0; i <= c; ++i) {
        L[i] = i - 1, R[i] = i + 1;// 水平双向链表
        U[i] = D[i] = i;// 垂直自环
    }
    L[0] = c, R[c] = 0, idx = c; // 将列头尾连成循环链表
    memset(first, 0, sizeof(first));// 每行第一个节点初始化为0
    memset(siz, 0, sizeof(siz));    // 每列计数清零
}

// 在位置(r, c)插入一个节点
// 即在r的右边c的下方插入
void insert(const int& r, const int& c) {
    row[++idx] = r, col[idx] = c, ++siz[c];
    U[idx] = c, D[idx] = D[c], U[D[c]] = idx, D[c] = idx;
    if (!first[r])
        first[r] = L[idx] = R[idx] = idx;
    else {
        L[idx] = first[r], R[idx] = R[first[r]];
        L[R[first[r]]] = idx, R[first[r]] = idx;
    }
}
//dance() 即为递归地删除以及还原各个行列的过程。
//如果[0] 号结点没有右结点，那么矩阵为空，记录答案并返回；
//选择列元素个数最少的一列，并删掉这一列；
//遍历这一列所有有[1] 的行，枚举它是否被选择；
//递归调用 dance()，如果可行，则返回；如果不可行，则恢复被选择的行；
//如果无解，则返回。

int stk[MS];  // 存储选择的行的栈（需外部声明）
int ans;      // 答案（需外部声明）

bool dance(int dep) {
    int i, j, c = R[0];
    if (!R[0]) {
        ans = dep;  // 记录解的行数
        return true;
    }
    // 启发式：选择节点数最少的列（加速搜索）
    int c = R[0];
    for (int i = R[0]; i != 0; i = R[i])
        if (siz[i] < siz[c]) c = i;
    
    remove(c);  // 删除该列

    // 遍历列c的所有行
    for (int i = D[c]; i != c; i = D[i]) {
        stk[dep] = row[i];  // 记录当前行作为解的一部分
        
        // 删除当前行覆盖的所有列
        for (int j = R[i]; j != i; j = R[j]) 
            remove(col[j]);
        
        // 递归搜索下一层
        if (dance(dep + 1)) return true;
        
        // 回溯：恢复删除的行
        for (int j = L[i]; j != i; j = L[j]) 
            recover(col[j]);
    }
    recover(c);
    return false;
}

```

## 代码示例1  剪枝，爽！
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 200010;

int m = 16 * 16 * 4;
int r[N],l[N],u[N],d[N],s[N],col[N],row[N],idx;
int ans[N],top;
struct Op
{
    int x, y;
    char z;
}op[N];
char g[20][20];

void init()
{
    for (int i = 0 ; i <= m ; i ++)
    {
        l[i] = i - 1,r[i] = i + 1;
        s[i] = 0;//由于多组数据，所以s要初始化
        u[i] = d[i] = i;
    }

    l[0] = m,r[m] = 0;
    idx = m + 1;
}


//十字链表基本操作
void add (int &hh,int &tt,int x,int y)
{
    row[idx] = x, col[idx] = y, s[y] ++;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;
    l[idx] = hh,r[idx] = tt,r[hh] = idx,l[tt] = idx;
    tt = idx ++;
}

void Remove(int p)
{
    l[r[p]] = l[p],r[l[p]] = r[p];//将p这一列从表头删去

    for (int i = d[p] ; i != p ; i = d[i])//遍历这一列是一的行
        for (int j = r[i] ; j != i ; j = r[j])//把这一行是一的全删去，因为这一行一定不会被选了
        {
            s[col[j]] --;//这一列的一个数减少
            u[d[j]] = u[j],d[u[j]] = d[j]; //进行删去
        }
}

void resume(int p)//p这一列的恢复，与上个函数相反
{
    for (int i = u[p] ; i != p ; i = u[i])
        for (int j = l[i] ; j != i ; j = l[j])
        {
            u[d[j]] = j,d[u[j]] = j;
            s[col[j]] ++;
        }
    l[r[p]] = p,r[l[p]] = p;
}

bool dfs()
{
    if (!r[0])return true;//表示结束

    int p = r[0];
    for (int i = r[0] ; i ; i = r[i])
        if (s[i] < s[p])
            p = i;//找到列上1个数最小的列

    Remove(p);
    for (int i = d[p] ; i != p ; i = d[i])//遍历选择这一列哪一个1
    {
        ans[++ top] = row[i];//选第i行的1
        for (int j = r[i] ; j != i ; j = r[j])Remove(col[j]);//把第i行有一的列全删去

        if (dfs())return true;//继续深搜

        for (int j = l[i] ; j != i ; j = l[j])resume(col[j]);//恢复现场
        top --;//删去选的行
    }
    resume(p);//恢复现场

    return false;//找不到答案
}

int main()
{
    while (~scanf("%s", g[0]))//处理多组输入
    {
        for (int i = 1; i < 16; i ++ ) scanf("%s", g[i]);
        init();//初始化

        for (int i = 0, n = 1 ; i < 16 ; i ++)//n为所建图的行数
            for (int j = 0 ; j < 16 ; j ++)
            {
                int a = 0,b = 15;//a，b为数独上该格能填的数范围
                if (g[i][j] != '-')a = b = g[i][j] - 'A';//表示该格已被填，只有一种选择

                for (int k = a ; k <= b ; k ++ , n ++)//遍历每一种选择，进行建图
                {
                    int hh = idx,tt = idx;
                    op[n] = {i, j, k + 'A'};//所建图第n行所代表的信息
                    add (hh, tt, n, i * 16 + j + 1);
                    add (hh, tt, n, 256 + i * 16 + k + 1);
                    add (hh, tt, n, 256 * 2 + j * 16 + k + 1);
                    add (hh, tt, n, 256 * 3 + (i / 4 * 4 + j / 4) * 16 + k + 1);
                }
            }

        dfs();

        for (int i = 1 ; i <= top ; i ++)
        {
            auto t = op[ans[i]];
            g[t.x][t.y] = t.z;
        }

        for (int i = 0 ; i < 16 ; i ++)puts(g[i]);
        puts("");

    }
    return 0;
}
```

## 代码示例1  DLX
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 200010;

int m = 16 * 16 * 4;
int r[N],l[N],u[N],d[N],s[N],col[N],row[N],idx;
int ans[N],top;
struct Op
{
    int x, y;
    char z;
}op[N];
char g[20][20];

void init()
{
    for (int i = 0 ; i <= m ; i ++)
    {
        l[i] = i - 1,r[i] = i + 1;
        s[i] = 0;//由于多组数据，所以s要初始化
        u[i] = d[i] = i;
    }

    l[0] = m,r[m] = 0;
    idx = m + 1;
}


//十字链表基本操作
void add (int &hh,int &tt,int x,int y)
{
    row[idx] = x, col[idx] = y, s[y] ++;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;
    l[idx] = hh,r[idx] = tt,r[hh] = idx,l[tt] = idx;
    tt = idx ++;
}

void Remove(int p)
{
    l[r[p]] = l[p],r[l[p]] = r[p];//将p这一列从表头删去

    for (int i = d[p] ; i != p ; i = d[i])//遍历这一列是一的行
        for (int j = r[i] ; j != i ; j = r[j])//把这一行是一的全删去，因为这一行一定不会被选了
        {
            s[col[j]] --;//这一列的一个数减少
            u[d[j]] = u[j],d[u[j]] = d[j]; //进行删去
        }
}

void resume(int p)//p这一列的恢复，与上个函数相反
{
    for (int i = u[p] ; i != p ; i = u[i])
        for (int j = l[i] ; j != i ; j = l[j])
        {
            u[d[j]] = j,d[u[j]] = j;
            s[col[j]] ++;
        }
    l[r[p]] = p,r[l[p]] = p;
}

bool dfs()
{
    if (!r[0])return true;//表示结束

    int p = r[0];
    for (int i = r[0] ; i ; i = r[i])
        if (s[i] < s[p])
            p = i;//找到列上1个数最小的列

    Remove(p);
    for (int i = d[p] ; i != p ; i = d[i])//遍历选择这一列哪一个1
    {
        ans[++ top] = row[i];//选第i行的1
        for (int j = r[i] ; j != i ; j = r[j])Remove(col[j]);//把第i行有一的列全删去

        if (dfs())return true;//继续深搜

        for (int j = l[i] ; j != i ; j = l[j])resume(col[j]);//恢复现场
        top --;//删去选的行
    }
    resume(p);//恢复现场

    return false;//找不到答案
}

int main()
{
    while (~scanf("%s", g[0]))//处理多组输入
    {
        for (int i = 1; i < 16; i ++ ) scanf("%s", g[i]);
        init();//初始化

        for (int i = 0, n = 1 ; i < 16 ; i ++)//n为所建图的行数
            for (int j = 0 ; j < 16 ; j ++)
            {
                int a = 0,b = 15;//a，b为数独上该格能填的数范围
                if (g[i][j] != '-')a = b = g[i][j] - 'A';//表示该格已被填，只有一种选择

                for (int k = a ; k <= b ; k ++ , n ++)//遍历每一种选择，进行建图
                {
                    int hh = idx,tt = idx;
                    op[n] = {i, j, k + 'A'};//所建图第n行所代表的信息
                    add (hh, tt, n, i * 16 + j + 1);
                    add (hh, tt, n, 256 + i * 16 + k + 1);
                    add (hh, tt, n, 256 * 2 + j * 16 + k + 1);
                    add (hh, tt, n, 256 * 3 + (i / 4 * 4 + j / 4) * 16 + k + 1);
                }
            }

        dfs();

        for (int i = 1 ; i <= top ; i ++)
        {
            auto t = op[ans[i]];
            g[t.x][t.y] = t.z;
        }

        for (int i = 0 ; i < 16 ; i ++)puts(g[i]);
        puts("");

    }
    return 0;
}

```
### [>>>点我返回目录位置<<<](#section1)
<br>
<br>
<br>
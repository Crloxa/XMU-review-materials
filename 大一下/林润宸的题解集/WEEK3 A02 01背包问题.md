# **<span id="section3A02"></span>WEEK3 A02 01背包问题**

## 题目分析

**给定N个只能装一次的物品和V的容量的背包以及每个物品的价值，求背包能装下的最大价值的物品。**

## 解题思路

### 线性DP

**其中dp数组代表前i个物品放入容量为j的背包的最大价值。**

1. **输入完数据以后如果当前容量无法容纳第i个物品：**

    -继承前i-1个物品的结果，**dp[i][j] = dp[i - 1][j];**

2. **当前容量可以容纳第i个物品：**

    - 决策：不放入i 或 放入i中取最大值：**dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - a[i]] + p[i])**

3. **关键点：** 第i个物品是否放入和之前做过的决策有关系，dp[i]的状态与dp[i-1]息息相关

4. 参考代码在代码示例1

## 优化

### **1. 滚动数组** 

- **我们发现，每次求背包的新状态时，只会出现i与i-1的dp数组，于是考虑用滚动数组解决这个问题**

    - 关键在于dp数组的状态为dp[2][N]，边输入边处理，参考代码示例2


### **2. 一维数组直接边输入边处理** 

- **我们又发现，每次求背包的新状态时，只要保存好原本的状态就会马上更新，我们只需要最终状态，并不在乎过程如何实现**

    - 于是直接输入时就处理，需要注意的是，此时我们会从大到小遍历背包（避免重复装，变成完全背包问题）



## 代码示例1
```cpp
#include<vector>
#include<string>
#include<queue>
#include<deque>
#include<unordered_map>
#include<unordered_set>
#include<cstring>
#include<cstdio>
#include<cstdlib>
using namespace std;
//ios::sync_with_stdio(false);
    //cin.tie(nullptr);
    //cout.tie(nullptr);

const int N = 1003;
int n, v;// n-物品数量, v-背包容量
// a[i]-第i个物品的体积, p[i]-第i个物品的价值
// dp[i][j]：前i个物品放入容量为j的背包的最大价值
int a[N], p[N], dp[N][N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> n >> v;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        cin >> p[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= v; j++) {
            if (j < a[i])
                // 当前容量无法容纳物品i
                // 继承前i-1个物品的结果
                dp[i][j] = dp[i - 1][j];
            else
                // 决策：不放入i 或 放入i（取最大值）
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - a[i]] + p[i]);
        }
    }
    cout << dp[n][v] << endl;
    return 0;
}
```

## 代码示例2
```cpp
const int N = 1003;
int v[N];
int w[N];
int f[2][N];
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i ++) cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i ++){
        for(int j = 0;j <= m;j ++){
            f[i & 1][j] = f[i - 1 & 1][j];
            if(j >= v[i]) f[i & 1][j] = max(f[i & 1][j],f[i - 1 & 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n&1][m];
    return 0;
}
```


## 代码示例3
```cpp
const int MAXN = 1003;
int f[MAXN];  //f[i]表示容量为i的背包能获得的最大价值

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n, m;   // n-物品数量, m-背包总容量
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        int v, w;   // v-当前物品体积, w-当前物品价值
        cin >> v >> w;      // 边输入边处理
        // 关键：从大到小遍历背包容量（逆序）
        for (int j = m; j >= v; j--)
            // 状态转移方程：
            // 选择1：不装当前物品 → f[j] 保持不变
            // 选择2：装当前物品 → f[j-v] + w（腾出v空间后的最优解加上当前物品价值）
            f[j] = max(f[j], f[j - v] + w);
    }
    cout << f[m] << endl;
    return 0;
}
```
### [>>>点我返回目录位置<<<](#section1)
<br>
<br>
<br>